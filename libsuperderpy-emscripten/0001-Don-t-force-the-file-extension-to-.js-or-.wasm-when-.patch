From 3d383c918a5303eafb327261296ba1c77f98f424 Mon Sep 17 00:00:00 2001
From: Sebastian Krzyszkowiak <dos@dosowisko.net>
Date: Thu, 10 Jan 2019 05:26:53 +0100
Subject: [PATCH] Don't force the file extension to .js or .wasm when compiling
 side modules

Specifying -s SIDE_MODULE=1 (or =2) is already enough to determine the file
type. Emscripten's preload plugins already expect WASM side modules to have
.so extension, so this fixes a peculiar situation where Emscripten can't
produce a file in a way Emscripten itself expects it to be later.
---
 emcc.py | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/emcc.py b/emcc.py
index 0f77703ff..e94bb74e8 100755
--- a/emcc.py
+++ b/emcc.py
@@ -955,7 +955,7 @@ There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR P
 
     # If not compiling to JS, then we are compiling to an intermediate bitcode objects or library, so
     # ignore dynamic linking, since multiple dynamic linkings can interfere with each other
-    if get_file_suffix(target) not in JS_CONTAINING_ENDINGS or options.ignore_dynamic_linking:
+    if (get_file_suffix(target) not in JS_CONTAINING_ENDINGS and 'SIDE_MODULE=1' not in settings_changes and 'SIDE_MODULE=2' not in settings_changes) or options.ignore_dynamic_linking:
       def check(input_file):
         if get_file_suffix(input_file) in DYNAMICLIB_ENDINGS:
           if not options.ignore_dynamic_linking:
@@ -1060,6 +1060,11 @@ There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR P
     elif shared.Settings.SIDE_MODULE:
       assert not shared.Settings.MAIN_MODULE
       options.memory_init_file = False # memory init file is not supported with asm.js side modules, must be executable synchronously (for dlopen)
+      # SIDE_MODULE+WASM combo unambiguously specifies what kind of file we want to output, so we don't have to fiddle with file extension
+      if shared.Settings.WASM:
+        wasm_binary_target = target
+      else:
+        js_target = target
 
     if shared.Settings.MAIN_MODULE or shared.Settings.SIDE_MODULE:
       assert shared.Settings.ASM_JS, 'module linking requires asm.js output (-s ASM_JS=1)'
@@ -1608,7 +1613,7 @@ There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR P
 
       # Decide what we will link
       executable_endings = JS_CONTAINING_ENDINGS + ('.wasm',)
-      stop_at_bitcode = final_suffix not in executable_endings
+      stop_at_bitcode = final_suffix not in executable_endings and not shared.Settings.SIDE_MODULE
 
       if stop_at_bitcode or not shared.Settings.WASM_BACKEND:
         # Filter link flags, keeping only those that shared.Building.link knows
@@ -1651,9 +1656,7 @@ There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR P
             # Sort arg tuples and pass the extracted values to link.
             shared.Building.link(linker_inputs, specified_target)
         logger.debug('stopping at bitcode')
-        if shared.Settings.SIDE_MODULE:
-          exit_with_error('SIDE_MODULE must only be used when compiling to an executable shared library, and not when emitting LLVM bitcode. That is, you should be emitting a .wasm file (for wasm) or a .js file (for asm.js). Note that when compiling to a typical native suffix for a shared library (.so, .dylib, .dll; which many build systems do) then Emscripten emits an LLVM bitcode file, which you should then compile to .wasm or .js with SIDE_MODULE.')
-        if final_suffix.lower() in ('.so', '.dylib', '.dll'):
+        if final_suffix.lower() in ['so', 'dylib', 'dll']:
           logger.warning('When Emscripten compiles to a typical native suffix for shared libraries (.so, .dylib, .dll) then it emits an LLVM bitcode file. You should then compile that to an emscripten SIDE_MODULE (using that flag) with suffix .wasm (for wasm) or .js (for asm.js). (You may also want to adapt your build system to emit the more standard suffix for a file with LLVM bitcode, \'.bc\', which would avoid this warning.)')
         return 0
 
-- 
2.20.1

