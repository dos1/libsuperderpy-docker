From 35d8cb3ffb9f08a3207734b9168f54b843a7509a Mon Sep 17 00:00:00 2001
From: Sebastian Krzyszkowiak <dos@dosowisko.net>
Date: Thu, 10 Jan 2019 05:26:53 +0100
Subject: [PATCH] Don't force the file extension to .js or .wasm when compiling
 side modules

Specifying -s SIDE_MODULE=1 (or =2) is already enough to determine the file
type. Emscripten's preload plugins already expect WASM side modules to have
.so extension, so this fixes a peculiar situation where Emscripten can't
produce a file in a way Emscripten itself expects it to be later.
---
 emcc.py | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/emcc.py b/emcc.py
index 2e7d26761..f54b6b568 100755
--- a/emcc.py
+++ b/emcc.py
@@ -949,7 +949,7 @@ There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR P
 
     # If not compiling to JS, then we are compiling to an intermediate bitcode objects or library, so
     # ignore dynamic linking, since multiple dynamic linkings can interfere with each other
-    if filename_type_suffix(target) not in JS_CONTAINING_SUFFIXES or options.ignore_dynamic_linking:
+    if (filename_type_suffix(target) not in JS_CONTAINING_SUFFIXES and 'SIDE_MODULE=1' not in settings_changes and 'SIDE_MODULE=2' not in settings_changes) or options.ignore_dynamic_linking:
       def check(input_file):
         if filename_type_ending(input_file) in DYNAMICLIB_ENDINGS:
           if not options.ignore_dynamic_linking:
@@ -1054,6 +1054,11 @@ There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR P
     elif shared.Settings.SIDE_MODULE:
       assert not shared.Settings.MAIN_MODULE
       options.memory_init_file = False # memory init file is not supported with asm.js side modules, must be executable synchronously (for dlopen)
+      # SIDE_MODULE+WASM combo unambiguously specifies what kind of file we want to output, so we don't have to fiddle with file extension
+      if shared.Settings.WASM:
+        wasm_binary_target = target
+      else:
+        js_target = target
 
     if shared.Settings.MAIN_MODULE or shared.Settings.SIDE_MODULE:
       assert shared.Settings.ASM_JS, 'module linking requires asm.js output (-s ASM_JS=1)'
@@ -1564,7 +1569,7 @@ There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR P
               temp_files[pos] = (temp_files[pos][0], new_temp_file)
 
       # Decide what we will link
-      stop_at_bitcode = final_suffix not in EXECUTABLE_SUFFIXES
+      stop_at_bitcode = final_suffix not in EXECUTABLE_SUFFIXES and not shared.Settings.SIDE_MODULE
 
       if stop_at_bitcode or not shared.Settings.WASM_BACKEND:
         # Filter link flags, keeping only those that shared.Building.link knows
@@ -1607,8 +1612,6 @@ There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR P
             # Sort arg tuples and pass the extracted values to link.
             shared.Building.link(linker_inputs, specified_target)
         logger.debug('stopping at bitcode')
-        if shared.Settings.SIDE_MODULE:
-          exit_with_error('SIDE_MODULE must only be used when compiling to an executable shared library, and not when emitting LLVM bitcode. That is, you should be emitting a .wasm file (for wasm) or a .js file (for asm.js). Note that when compiling to a typical native suffix for a shared library (.so, .dylib, .dll; which many build systems do) then Emscripten emits an LLVM bitcode file, which you should then compile to .wasm or .js with SIDE_MODULE.')
         if final_suffix.lower() in ['so', 'dylib', 'dll']:
           logger.warning('When Emscripten compiles to a typical native suffix for shared libraries (.so, .dylib, .dll) then it emits an LLVM bitcode file. You should then compile that to an emscripten SIDE_MODULE (using that flag) with suffix .wasm (for wasm) or .js (for asm.js). (You may also want to adapt your build system to emit the more standard suffix for a file with LLVM bitcode, \'.bc\', which would avoid this warning.)')
         return 0
-- 
2.20.1

